# visualize_T.py
"""
Visualizes trajectory improvement (T-score) by comparing paths.

Loads:
- The ranked top-k candidates from evaluate_population_AT.py
- The original episode/critical state data

Generates a side-by-side comparison:
- Left: Original grid + GROUND TRUTH path (from episode_logs)
- Right: Candidate grid + PPO policy rollout path (from topk_ranked.json)
"""
import json
import os
import numpy as np
import matplotlib.pyplot as plt
import matplotlib.patches as patches
import matplotlib.colors as mcolors
# from stable_baselines3 import PPO # <- No longer needed

# --- 1. CONFIGURATION ---

# File generated by evaluate_population_AT.py
TOPK_FILE = "populations/evaluated_AT/topk_ranked.json"

# Files needed to get the original grid and s_star
CRITICAL_STATES_FILE = "critical_states.json"
EPISODES_FILE = "episode_logs/episodes_full.json"

# The index corresponding to the run (must match the one used in evaluate_population_AT.py)
CRITICAL_INDEX = 9

# Directory where the output images will be saved
OUTPUT_DIR = "visualizations_T"

# --- 2. Style Configuration (Copied from visualize_sparsity.py) ---
OBJECT_TO_INT = {"empty": 0, "Wall": 1, "Door": 2, "Key": 3, "Goal": 4}
custom_colors = [
    'white',       # 0: empty
    'darkgrey',    # 1: Wall
    'saddlebrown', # 2: Door
    'gold',        # 3: Key
    'limegreen'    # 4: Goal
]
cmap = mcolors.ListedColormap(custom_colors)
bounds = [i - 0.5 for i in range(len(OBJECT_TO_INT) + 1)]
norm = mcolors.BoundaryNorm(bounds, cmap.N)

# --- 3. Helper Functions ---

def get_ground_truth_path_from_log(episode_record, critical_step_t):
    """
    Extracts the ground-truth path and its length (tile transitions)
    from the episode log, starting from the critical step t.
    """
    # The critical state s* is the *start* of our remaining path.
    start_pos = tuple(episode_record["steps"][critical_step_t]["pos"])
    
    # The rest of the path is all positions *after* t
    path_coords = [start_pos]
    for step in episode_record["steps"][critical_step_t + 1:]:
        path_coords.append(tuple(step["pos"]))

    # Add goal if successful
    if episode_record.get("success", False):
        try:
            grid = episode_record["initial_grid"]
            goal_pos = None
            for r, row in enumerate(grid):
                for c, cell in enumerate(row):
                    if cell == "Goal":
                        goal_pos = (c, r)
                        break
            if goal_pos and path_coords[-1] != goal_pos:
                path_coords.append(goal_pos)
        except Exception:
            pass # Goal finding failed, just use last recorded step
    
    # Calculate path length based on tile transitions
    transitions = 0
    for i in range(1, len(path_coords)):
        if path_coords[i] != path_coords[i-1]:
            transitions += 1
            
    return transitions, path_coords


def fetch_original_data(episodes_path, criticals_path, critical_index):
    """Loads the original grid, s_star, and full episode record."""
    with open(episodes_path, 'r') as f:
        episodes = json.load(f)
    with open(criticals_path, 'r') as f:
        crits = json.load(f)

    if critical_index >= len(crits):
        raise IndexError(f"Critical index {critical_index} out of range for critical_states.json")

    crit = crits[critical_index]
    ep_id = crit["episode_id"]
    ep_map = {ep['episode_id']: ep for ep in episodes}
    
    if ep_id not in ep_map:
        raise KeyError(f"Episode ID {ep_id} from critical state not found in episodes file.")

    episode_record = ep_map[ep_id]
    orig_grid = episode_record["initial_grid"]
    s_star = crit["s_star"]
    
    # Return the full episode record as well
    return orig_grid, s_star, ep_id, episode_record, crit['critical_step_t']

def grid_to_int_array(grid_str):
    """Converts the string grid to a numpy array for imshow."""
    return np.array([[OBJECT_TO_INT.get(tile, 0) for tile in row] for row in grid_str])

def plot_path_on_ax(ax, positions, color, label):
    """Draws a list of (x,y) positions on a matplotlib axis."""
    if not positions:
        return
    xs = [p[0] for p in positions]
    ys = [p[1] for p in positions]
    # Plot path line
    ax.plot(xs, ys, marker='o', markersize=4, linestyle='-', linewidth=1.5, color=color, label=label, alpha=0.8)
    # Highlight start position
    ax.plot(xs[0], ys[0], marker='*', markersize=18, markeredgecolor='black', color=color, label=f"{label} Start")

# --- 4. Main Visualization Function ---

def main():
    # --- 1. Load all data ---
    if not all(os.path.exists(f) for f in [TOPK_FILE, CRITICAL_STATES_FILE, EPISODES_FILE]):
        print("Error: One or more required files not found. Check CONFIGURATION section.")
        return
        
    print(f"Loading top-k candidates from {TOPK_FILE}...")
    with open(TOPK_FILE, 'r') as f:
        topk_data = json.load(f)
        
    print(f"Loading original grid and s_star (index {CRITICAL_INDEX})...")
    orig_grid, s_star, ep_id, episode_record, crit_t = fetch_original_data(
        EPISODES_FILE, CRITICAL_STATES_FILE, CRITICAL_INDEX
    )
    
    # --- 2. ✅ FIX: Get ground-truth original path from the LOG ---
    print(f"Reading ground-truth path from log for Episode {ep_id} at t={crit_t}...")
    orig_path_len, original_path_positions = get_ground_truth_path_from_log(episode_record, crit_t)
    print(f"Ground-truth path length = {orig_path_len} transitions.")
    
    os.makedirs(OUTPUT_DIR, exist_ok=True)
    print(f"\nStarting visualization... outputting to '{OUTPUT_DIR}'")

    # --- 3. Loop and plot each candidate ---
    for i, candidate in enumerate(topk_data):
        
        # --- Extract data for this candidate ---
        candidate_grid_str = candidate["grid"]
        agent_start_pos = tuple(s_star["pos"])

        # Get scores
        t_result = candidate.get('t_result', {})
        a_result = candidate.get('a_result', {})
        t_score = t_result.get('T', 0.0)
        a_score = a_result.get('a_score', 0.0)
        # Get the path lengths *as calculated by the evaluation script*
        orig_len_from_json = t_result.get('path_orig', 'N/A')
        cf_len = t_result.get('cf_path_len_median', 'N/A')
        
        # Get the first rollout path for the candidate
        candidate_path_positions = candidate.get('t_result', {}).get('t_diag', {}).get('positions', [[]])[0]

        # --- Convert grids to int arrays ---
        original_grid_int = grid_to_int_array(orig_grid)
        modified_grid_int = grid_to_int_array(candidate_grid_str)

        # --- Create Subplots ---
        fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(16, 8), dpi=100)
        fig.suptitle(f"Candidate {i} (T-Score: {t_score:.3f} | A-Score: {a_score:.3f})", fontsize=18, weight='bold')

        # --- Plot Original Grid (Left) ---
        ax1.imshow(original_grid_int, cmap=cmap, norm=norm, origin='lower')
        # Use the length from the JSON for the title, but the path from our log helper
        ax1.set_title(f"Original Grid (Ground Truth Path Length: {orig_len_from_json})", fontsize=14)
        plot_path_on_ax(ax1, original_path_positions, color='red', label='Orig. Path')
        ax1.legend(loc='upper right')
        
        # --- Plot Modified Grid (Right) ---
        ax2.imshow(modified_grid_int, cmap=cmap, norm=norm, origin='lower')
        ax2.set_title(f"Candidate Grid (Median CF Path Length: {cf_len})", fontsize=14)
        plot_path_on_ax(ax2, candidate_path_positions, color='blue', label='CF Path')
        ax2.legend(loc='upper right')

        # --- Add shared, descriptive colorbar ---
        cbar_ax = fig.add_axes([0.92, 0.25, 0.02, 0.5])
        mappable = plt.cm.ScalarMappable(cmap=cmap, norm=norm)
        cbar = fig.colorbar(mappable, cax=cbar_ax, ticks=np.arange(len(OBJECT_TO_INT)))
        cbar.ax.set_yticklabels(list(OBJECT_TO_INT.keys()), fontsize=12)

        # --- Save ---
        plt.tight_layout(rect=[0, 0, 0.9, 1])
        filename = f"t_comparison_{i:03d}_T_{t_score:.3f}.png"
        output_path = os.path.join(OUTPUT_DIR, filename)
        plt.savefig(output_path, bbox_inches='tight')
        plt.close(fig)
        
        print(f"[{i+1}/{len(topk_data)}] Saved visualization to {output_path}")

    print("\n✅ Batch visualization complete!")

if __name__ == "__main__":
    main()